#include "lib.h"
#include "i8259.h"
#include "keyboard.h"
#include "scan_code.h"
#include "tests.h"
#include "syscall.h"
#define KEYBOARD_DATA_PORT 0x60
#define KEYBOARD_STATUS_PORT 0x64
#define KEYBOARD_COMMAND_PORT 0x64
#define KEYBOARD_IRQ_NUM 1

#define LSHIFT_IND  0
#define RSHIFT_IND  1
#define CAPSLOCK_IND 2
#define CTRL_IND 3
#define RELEASE(i) (i-128)
#define MAX_KEY_IND 127
#define TOTAL_KEY_NUM 128
#define PRINT_LIM 1025*2
#define TERMINAL_NUM 3
int8_t pressed_key[TOTAL_KEY_NUM];
unsigned char keyboard_buffer[TERMINAL_NUM][TOTAL_KEY_NUM+1];
unsigned char print_buffer[TERMINAL_NUM][PRINT_LIM];
int cap_status;
int cursor_ind[TERMINAL_NUM];
int hold_num;
int terminal_read_ready[TERMINAL_NUM];
int need_nl = 0;
volatile int terminal_2_running = 0, terminal_3_running = 0;
/* keyboard initilization
 *
 * initialize the keyboard and let it begin generating interrupts
 * Inputs: None
 * Outputs: None
 * Side Effects: irq 1 is enabled
 */
void init_keyboard()
{
    /* keyboard irq locate at 1*/
    init_scan_code();
    enable_irq(KEYBOARD_IRQ_NUM);
    memset(pressed_key, 0 , sizeof(pressed_key) );
    memset(keyboard_buffer, 0 , sizeof(keyboard_buffer));
    memset(cursor_ind, 0 , sizeof(cursor_ind));
    memset(terminal_read_ready, 0,  sizeof(terminal_read_ready));
    hold_num = 0;
    cap_status = 0;
}
/* change by shift */
unsigned char char_match(unsigned char c)
{
    if( scan_code[c] ==0 ) return 0;
    unsigned char res = scan_code[c];
    if( (cap_status == 1) && (res>='a') && (res<='z') ){
    	if( (pressed_key[LEFTSHIFT]==1) || (pressed_key[RIGHTSHIFT]==1)){
        	res = scan_code[c];
		}
		else{
			res = shift_convert[c];
		}
	}
	else if( (pressed_key[LEFTSHIFT]==1) || (pressed_key[RIGHTSHIFT]==1)){
        	res = shift_convert[c];
		}
    return res;
}

/* keyboard interrupt handler
 *
 * handle the interrupt generated by keyboard
 * Inputs: None
 * Outputs: None
 * Side Effects: read ch from buffer, called the interruption test
 */
void keyboard_handler()
{
    cli(); //disable interrupts
    send_eoi(KEYBOARD_IRQ_NUM);
    //clear();
    unsigned char input;
    while( (inb(KEYBOARD_STATUS_PORT)&0x1)>0 ) //use 0x1 to check the last bit, whether the buffer is still full.
    {
        input = inb(KEYBOARD_DATA_PORT);
		int terminal_id;
		terminal_id=get_display_terminal();
		//////////////////////////////////////			
		if( input>MAX_KEY_IND )
		{
			pressed_key[ RELEASE(input) ] = 0;
			hold_num--;
		}		
		else
		{
			pressed_key[ input ] = 1;
			hold_num++;
			if( input== CAPSLOCK ) cap_status = 1-cap_status;
			if( (input==L) && (pressed_key[LEFTCTRL]==1)  )
			{
				clear();
				memset(keyboard_buffer[terminal_id], 0 , sizeof(keyboard_buffer[terminal_id]) );
				cursor_ind[terminal_id] = 0;
			}
			else if (  (pressed_key[LEFTALT]==1)  )
			{
				if(input == F1)
					set_disiplay_terminal(0);
				if(input == F2)
				{
					set_disiplay_terminal(1);

					if(!terminal_2_running)
					{
						if(get_pid()==-1) return;
						terminal_2_running = 1;
						//sti();
						execute_with_terminal_num((unsigned char *)"shell",1);
					}

				}
				if(input == F3)
				{
					set_disiplay_terminal(2);

					if(!terminal_3_running)
					{
						if(get_pid()==-1) return;
						terminal_3_running = 1;
						//sti();
						execute_with_terminal_num((unsigned char *)"shell",2);
					}

				}
			}
			else if(scan_code[input]!=0)
			{
				if(cursor_ind[terminal_id]>=MAX_KEY_IND+1)
				{
				}
				else
				{
					keyboard_buffer[terminal_id][ cursor_ind[terminal_id]++ ] = char_match(input);
					putc_scroll_display(char_match(input));
				}
			}
		}

		if(input==ENTER)
		{
			memset(print_buffer[terminal_id],0, sizeof(print_buffer[terminal_id]));
			memcpy(print_buffer[terminal_id], keyboard_buffer[terminal_id], sizeof(keyboard_buffer[terminal_id]));
			memset(keyboard_buffer[terminal_id], 0 , sizeof(keyboard_buffer[terminal_id]) );
			terminal_read_ready[terminal_id] = 1;
			cursor_ind[terminal_id] = 0;
		}

		if(input==BACKSPACE)
		{
			if(cursor_ind[terminal_id]!= 0)
			{
				keyboard_buffer[terminal_id][ --cursor_ind[terminal_id] ] = '\0';
				delete_c();
			}
		}
			
		//////////////////////////////////////
      
        
    }
    sti(); //re-enable interrupts
}
/*terminnal open function*/
int32_t terminal_open()
{
    return 0;
}
/*terminnal write function
input: buf = the buffer to write from, count = length*/
int32_t terminal_write(char* buf, int count)
{
    cli();
    int lim = sizeof(print_buffer[get_active_terminal()]);
    if(count<lim) lim = count;
    memcpy( print_buffer[get_active_terminal()], buf, lim );
    print_buffer[get_active_terminal()][lim] = 0;

    puts_scroll((char*)print_buffer[get_active_terminal()],lim);
    sti();
    //putc_scroll('\n');
    return count;
}

// See terminal_write
int32_t terminal_write_wrap(uint32_t inode, uint32_t offset, uint8_t* buf, uint32_t count)
{
    return terminal_write((char*)buf, (int)count);
}

/*terminnal close function*/
int32_t terminal_close()
{
    return 0;
}
/*terminnal read function*/
int32_t terminal_read(char* buf, int count)
{
    sti();
    while(terminal_read_ready[get_active_terminal()]!=1)
    {
    }
    memcpy(buf, print_buffer[get_active_terminal()], count);
    terminal_read_ready[get_active_terminal()] = 0;
    return strlen(buf);
}

//see terminal_read
int32_t terminal_read_wrap(uint32_t inode, uint32_t offset, uint8_t* buf, uint32_t count)
{
    return terminal_read((char*)buf, (int)count);
}

int terminal_wrong(uint32_t inode, uint32_t offset, uint8_t* buf, uint32_t count){
	return -1;
}
int terminal_nothing(uint32_t inode, uint32_t offset, uint8_t* buf, uint32_t count){
	return 0;
}

